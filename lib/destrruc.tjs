var modef = require('modef'),
	express = require('express');

var plur = modef.pluralize;

var opts = {
	id:		function(id) { return { _id: id }; },
	render:	function(req, res, modelName, entity, next) { res.json(entity); }
};


/********************************************************************
 * Crud Middleware
 */

function idFunc(id) {
	return opts.id(id);
}
function renderFunc(req, res, modelName, entity, next) {
	opts.render(req, res, modelName, entity, next);
}

function newEntity(req, res, next) {
	// console.log('new', req.modelName);
	req.entity = new req.model();
	req.entityNew = true;
	next();
}

function fetchEntity(req, res, next) {
	// console.log('fetch', req.q);
	var find = req.model.findOne(req.q);

	// populate connections
	var include = req.query.include;
	if (include) {
		include.split(',').forEach(function(inc) {
			// select fields
			var selects = inc.split('.');
			var fields = selects[1] ? selects[1].split('|') : [];
			find.populate(selects[0], fields);
		});
	}

	find.run(function(err, entity) {
		//if (err) return;
		req.entity = entity;
		next();
	});
}

function removeEntity(req, res, next) {
	// console.log('remove', req.q);
	// TODO: disconnect from any other entities
	req.model.remove(req.q, function(err) {
		next();
	});
}

function andUpdate(req, res, next) {
	var connections = modef.connected(req.modelName);
	var updates = req.updates = req.body[req.modelName];
	var entity = req.entity;
	// console.log('update', updates);

	for (field in updates) {
		// check connections for this field
		var connection = connections[field];
		if (connection && !connection.many) {
			// TODO: disconnect if field already connected

			// add this entity to related entites
			var otherModel = modef[connection.to];
			var q = idFunc(updates[field]);
			var addToSet = { $addToSet: { } }
			addToSet.$addToSet[plur(req.modelName)] = req.entity._id;
			// console.log(q);
			// console.log(addToSet);
			otherModel.update(q, addToSet).exec();
			
			// get other entity if idFunc did not set _id field
			if (!q._id) {
				var otherEntity;
				await {
					otherModel.findOne(q, defer(err, otherEntity));
				}
				updates[field] = otherEntity._id;
			}
		}
		// either push into field or set field
		if (entity[field] && entity[field].constructor == Array)
			entity[field].push(updates[field]);
		else
			entity[field] = updates[field];
	}
	next();
}

function andSave(req, res, next) {
	var entity = req.entity;
	entity.save(function(err) {
		if (err) return;
		auditAction(req);
		next();
	});
}

function andRedirect(req, res) {
	var entity = req.entity;
	res.redirect('/' + req.modelName + '/' + (entity[opts.idField] ? entity[opts.idField] : entity._id));
}

function andRender(req, res, next) {
	renderFunc(req, res, req.modelName, req.entity, next);
}

function andOK(req, res) {
	res.send('removed ' + req.modelName + '(' + JSON.stringify(req.q) + ')');
}


/********************************************************************
 * Express extension
 */

express.HTTPServer.prototype.destrruc =
express.HTTPSServer.prototype.destrruc = function destrruc(o) {
	for (opt in o) opts[opt] = o[opt];

	this.param('model', function(req, res, next, model) {
		// console.log('model', model);
		req.model = modef[model];
		req.modelName = model;
		next();
	});

	this.param('id', function(req, res, next, id) {
		var q = req.q = idFunc(id);
		// console.log('id %s =>', id, q);
		next();
	});

	this.get('/:model/:id', fetchEntity, andRender);
	this.post('/:model', newEntity, andUpdate, andSave, andRedirect);
	this.put('/:model/:id', fetchEntity, andUpdate, andSave, andRedirect);
	this.delete('/:model/:id', removeEntity, andOK);
};


/********************************************************************
 * Auditing
 */

var auditors = [];
function audit(callback) {
	auditors.push({
		callback: callback
	});
}

function auditAction(req) {
	var modelName = modef.alias(req.modelName);
	var entity = req.entity;
	var action = req.entityNew ? 'new' : 'update';
	var fields = req.updates;
	setTimeout(function() {
		auditors.forEach(function(auditor) {
			auditor.callback(action, modelName, entity, fields);
		});
	}, 0);
}

// exports
module.exports.audit = audit;
